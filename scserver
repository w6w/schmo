#!/bin/bash
######################################################################
#    SCHMO - System for Cluster's Humble Management and Operation    #
#                                                                    #
# scserver:                                                          #
#  Part of SCHMO system to manage cluster on very low couplin        #
#                                                                    #
# scserver -> (root) manager nodes and make settings                 #
# scstatus -> (user) get statistcs of nodes and jobs                 #
# scsub -> (user) send a job to a node                               #
# scdel -> (user) delete a job on an slave node                      #
# sccheck -> (user|root) checks dependencies and settings            #
#                                                                    #
# qstat, sinfo -> link para scstatus                                 #
# qsub, srun -> link to scsub                                        #
# qdel, scancel -> link to scdel                                     #
#                                                                    #
# Created by: Marcelo Giovani at 2018-07  (mgiovanibr@gmail.com)     #
#                                                                    #
# Last change (2018-07-24): Marcelo giovani                          #
# Under construction...                                              #
#                                                                    #
# Change (2018-07-22): Marcelo giovani                               #
# Version 0.0.1                                                      #
#                                                                    #
######################################################################

# Matar jobs de usuarios com credito esgotado (cgroups or su - USER -c "kill -a")
# Configurar automaticamente o cron
# Disable cron users on nodes: touch /var/spool/cron/crontabs/$username; chmod 0 /var/spool/cron/crontabs
# crontab --> /etc/cron.allow --> /etc/cron.deny

#####
_Version="0.0.1"
_ERROR="\e[1m\e[7mERROR\e[0m"
#_Bold="\e[1m"		#Bold
#_Low="\e[1m\e[32m"	#green
#_Mid="\e[1m\e[33m"	#yellow
#_High="\e[1m\e[31m"	#red
#_Norm="\e[0m"		#no_color
_Nodelist="/etc/schmo/nodes.enable"	#List of nodes to manager, thei IP must be in "/etc/hosts"
_Userlist="/etc/schmo/users.enable"	#List of users to manager
_Etc="/etc/schmo"
_Conect="ssh -p 13900 -l root "		#Command to conect on nodes
_LocalFolder="/var/schmo"		#Folder to store and manipulate data (chown USER if scserver run not root)
_Interval="2"				#Time to crontab rum scserver in minutes
_CreditDefault="1000000"		#Default CPU time credit if autogenerated 1,000,000 min/period "suggestion"
#####


function Start(){ #dep funcs "Help"
	_Par="$1" 
	[[ "$_Par" = "-V" || "$_Par" = "--version" ]] && echo "$_Version" && exit 0
	[[ "$_Par" = "-h" || "$_Par" = "--help" ]] && Help && exit 0
	if [[ ! -w "$_LocalFolder" ]] ; then
		echo -e "$_ERROR on \"$_LocalFolder\""
		echo "The user \"`whoami`\" must have write permition in \"$_LocalFolder\" "
		echo "Leaving the $0......"
		exit 1
	fi
	if [[ ! -w "$_Etc" ]] ; then
		echo -e "$_ERROR on \"$_Etc\""
		echo "The user \"`whoami`\" must have write permition in \"$_Etc\" "
		echo "Leaving the $0......"
		exit 1
	fi
	if [[ ! -d "$_LocalFolder/history" ]] ; then
		mkdir -v "$_LocalFolder/history" || $(echo -e "$_ERROR on create in $_machine $_LocalFolder/history\nLeaving the $0...... " && exit 1)
	fi
	_Users=`cat "$_Userlist" | awk '{print $1}' | grep -v "^#" | grep -v "^root$" | grep -v "^$" | tr "\n" " " `
	if [[ -z "$_Users" ]] ; then
		echo -e "$_ERROR on $_Userlist. \nCan't able to read this file or there is no \"users\" to manager. \nTrying to generate an automatic list..."
		_Users="$(cut -d: -f1,3 /etc/passwd | egrep ':[0-9]{4}$' | cut -d: -f1 | tr "\n" " " )" #; echo "_Users=.$_Users."
		echo -e "# Generated by $0 at `date +%Y-%m-%d_%H:%M`" > $_Userlist
		echo -e "# USERNAME\tquote(min)\tResidue" >> $_Userlist
		for i in $_Users ; do
			echo -e "$i\t\t$_CreditDefault\t\t0" >> $_Userlist
		done
		echo "Please, check \"$_Userlist\" and run \"$0\" again."
		exit 1
	fi
}

function Help(){
	echo -e "$0 version $_Version\n"
	echo -e "\tGenerates CPU time count per user and kill users jobs if their credits ending\n"
	echo -e "\tUser:\t$0\n\t\t$0 < -s | --setcron >\n"
	echo -e "\t< setcron > \t:configure crontab to run $0 every $_Interval minute.\n"
	#Need more and more info
}

function check_nodesaddress(){
	subfunc_error_nodesenable(){
		echo -e "$_ERROR ,some problem in the file \"$_Nodelist\" or in their respective IP address in the \"/etc/hosts\" file."
		echo "Leaving the $0......"
		exit 1
	}
	if [[ -r "$_Nodelist" ]] ; then
		_Target=`cat "$_Nodelist" | awk '{print $1}' | grep -v "^#" | grep -v "^$" | tr "\n" " " ` 
		[[ -z "$_Target" ]] && subfunc_error_nodesenable
	else
		subfunc_error_nodesenable
	fi
}

function check_user_credit(){
	#echo "_users=$_user ; _machine=$_machine" ; sleep 1	#debug
	#echo "CHECK_USER $_machine $_user `date +%s`" #debug
	_UserDebit1="0" ; _UserDebit2="0" ; _UserCredit="0"
	[[ -r $_Userlist ]] && _UserCredit=$(awk -v user="$_user" "{  if (\$1 == user) {printf \"%s\" , \$2 + \$3}  }"  $_Userlist)  
	[[ -r ""$_LocalFolder"/"$_user".running" ]] && _UserDebit1=$(awk "{sum += \$9} END {printf \"%s\" , sum}"  ""$_LocalFolder"/"$_user".running") 
	[[ -r ""$_LocalFolder"/"$_user".ended" ]] && _UserDebit2=$(awk "{sum += \$10} END {printf \"%s\" , sum}"  ""$_LocalFolder"/"$_user".ended") 
	_UserBalance=$(echo "$_UserCredit - $_UserDebit1 - $_UserDebit2" | bc)
	[[ "$_UserBalance" < "0" ]]  &&  _Kill="1" && echo "$_machine $_user=$_UserBalance, matando job........" #1/2 debug
	#echo "_user=$_user $_machine ; _UserCredit=$_UserCredit ; _UserDebit1=$_UserDebit1 ; _UserDebit2=$_UserDebit2 ; _UserBalance=$_UserBalance" 	#debug
}

function extermination(){	#It needs to be better, kill jobs with more than "X%" of CPU, aggressive killer if more than "Y" process or debit greater than "-Z hours" 
	for _machine in $_Target ; do 
		echo "Executando EXTERMINATOR para $_user em $_machine" #debug
		if `resolveip $_machine &> /dev/null` ; then
			$_Conect "$_machine" 2> /dev/null "
			subfunc_kill_remote(){
				hostname
				#date +%s
				echo ".$_user."
				whoami
				pgrep -u $_user | tr \"\n\" \" \"     #<<<<<<<<<<<<<<<<<< ESTOU AKIIIIIIIIIII ==========
				echo
			}
			subfunc_kill_remote
			"
		else
			echo -e "$_ERROR on connection to $_machine \n"
		fi
	done
}

function killer_user_jobs(){	#dep func "extermination" AND "check_user_credit" 
	for _user in $_Users ; do
		#echo "Exec killer_user_jobs para $_user"
		_Kill="0"
		check_user_credit
		[[ "$_Kill" -eq "1" ]] && extermination
	done
}

function local_parallel_cpu_processing(){
	#Case 1: Se um job NAO eh novo & aumentou o cputime -> substituir em "user.running"
	#Case 2: Se um job EH novo -> adicionar em "user.running"
	#Case 3: Se um job TERMINOU -> move from "user.running" to "user.ended" 
	_Day=`date +%Y%m%d`  
	_Userprocess=$( echo "$_RemotProcesses" | grep "^$_user " ) #; echo "_Userprocess=$_Userprocess"
	if [[ -n "$_Userprocess" ]] ; then	#case there are more users in master then slaves-nodes
		while read _line ; do
			_Verify="$(echo $_machine $_line | cut -d" " -f-8)"
			_CPUTimeJob="$(echo $_machine $_line | cut -d" " -f9 | tr -d "." )"
			>> "$_LocalFolder/"$_user".running"
			if [[ -n "$(grep "^$_Verify" "$_LocalFolder/"$_user".running" )" ]] ; then	#verify if there is no this job in user.running "Caso 1"
				#Substituir a linha "$_machine $_line" em "$_LocalFolder/"$_user"-"$_Day".day"
				_NumbLineSub="$(cat -n "$_LocalFolder/"$_user".running" | grep "$_Verify" | cut -f1)" #; echo _NumbLineSub=$_NumbLineSub  # Line Number to be replaced
				Tmp1="$(head -n "$_NumbLineSub" "$_LocalFolder/"$_user".running" | tail -n 1 | cut -d" " -f9  | tr -d ".")" #; echo "Tmp1=.$Tmp1."
				Tmp2=$((10#$Tmp1))
				Tmp3=$((10#$_CPUTimeJob))
				if [[ "$Tmp2" -lt "$Tmp3" ]] ; then #replace line only if cputime grown up
					#replace line only if new CPUTimeJos is great then CPUTimeJob in file "$_user.running"
					head -n $(($_NumbLineSub-1)) "$_LocalFolder/"$_user".running" > "$_LocalFolder/"$_user"-"$_Day".tmp"		#
					echo -e $_machine $_line >> "$_LocalFolder/"$_user"-"$_Day".tmp"						## 
					tail -n "+$(($_NumbLineSub+1))" "$_LocalFolder/"$_user".running" >> "$_LocalFolder/"$_user"-"$_Day".tmp"	###> Input new job in "user.runnig"
					mv "$_LocalFolder/"$_user"-"$_Day".tmp" "$_LocalFolder/"$_user".running"					#
				fi
			else #Job is NEW, insert in user.running "Case 2" 
				#if [[ "$(($(echo $_line | cut -d" " -f8 | tr -d ".")))" -gt "0" ]] ; then
					echo -e $_machine $_line >> "$_LocalFolder/"$_user".running" #echo "Making $_machine $_line"	#1/2debug
				#fi
			fi
		done < <(echo  "$_Userprocess")
		while read _line ; do #Job finished "Case 3"
		_line="$(echo $_line | cut -d" " -f2-20)"	#Nao remover pois a lina inicia com "machine" e esse termo deve sair
		_Stay="$(echo "$_RemotProcesses" | grep "^$_line")" #; echo "Stay=.$_Stay."
		if [[ -z "$_Stay" ]] ; then
			#Delete linha "alvo" de "user.running" e envia para "user.ended"
			_NumbLineSub="$(cat -n "$_LocalFolder/"$_user".running" | grep "$_machine $_line" | cut -f1)" #; echo _NumbLineSub=$_NumbLineSub
			_Ended="$(cat "$_LocalFolder/"$_user".running" | grep "^$_machine $_line" )" #; echo "_Ended=.$_Ended."
			#[[ "$(echo $_Ended | cut -d" " -f9)" != "0.00" ]] && #remover essa linhas
			echo "`date +%Y-%m-%d_%H:%M` $_Ended" >> "$_LocalFolder/"$_user".ended" #input line target in "user.ended"
			head -n $(($_NumbLineSub-1)) "$_LocalFolder/"$_user".running" > "$_LocalFolder/"$_user"-"$_Day".tmp"		#\ 
			tail -n "+$(($_NumbLineSub+1))" "$_LocalFolder/"$_user".running" >> "$_LocalFolder/"$_user"-"$_Day".tmp"	# > Delete line target from "user.running"
			mv "$_LocalFolder/"$_user"-"$_Day".tmp" "$_LocalFolder/"$_user".running"					#/
		fi
		done < <(grep "^$_machine " $_LocalFolder/"$_user".running)
	fi
	#sleep 4 ; echo "p fim `date +%s`"	#debug
}

function local_cpu_time_count_per_user(){	#dep funcs "local_parallel_cpu_processing"
	# Check race condition about "_user" and "_machine". My be needed internal "_ibg_user=$_user" "ibg_machine="$_machine"
	for _user in $_Users ; do
		local_parallel_cpu_processing &
	done
}

function cpu_time_count_per_machine(){  #dep funcs "local_cpu_time_count_per_user"
	for _machine in $_Target ; do
		if `resolveip $_machine &> /dev/null` ; then
			_RemotProcesses="$($_Conect "$_machine" 2> /dev/null '
				ps -e --no-header --cumulative -o user,pid,lstart,bsdtime,command | awk "{ {sub(/:/,\".\",\$8)} if (\$8 > \"0.00\") {print} }"
			' ) "
			local_cpu_time_count_per_user
		else
			echo -e "$_ERROR on connection to $_machine \n"
		fi
	done
 }

# FALTA fazer funcao de rotacionar os creditos
# FALTA fazer funcao para matar jobs caso acabe os creditos

##### Main
Start "$@"
check_nodesaddress
cpu_time_count_per_machine
wait #Aguarda processos paralelos anteriores terminarem
killer_user_jobs
##### End Main

exit 0


